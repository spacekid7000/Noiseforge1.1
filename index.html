<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Noise Forge - Lo-Fi Degradation Playground</title>
<style>
:root {
  --bg-color: #121212;
  --surface-color: #1e1e1e;
  --primary-text-color: #e0e0e0;
  --secondary-text-color: #a0a0a0;
  --border-color: #2c2c2c;
  --accent-color: #007bff;
  --interactive-bg: #2a2a2a;
  --interactive-hover: #383838;
  --border-radius: 6px;
  --transition-speed: 0.2s;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  background-color: var(--bg-color);
  color: var(--primary-text-color);
  font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  padding: 1rem 2rem;
  display: flex;
  justify-content: center;
  align-items: flex-start;
  min-height: 100vh;
}

.container {
  width: 100%;
  max-width: 1500px;
}

header {
  text-align: center;
  margin-bottom: 2rem;
}

h1 {
  font-size: 2.5rem;
  font-weight: 500;
  letter-spacing: 2px;
  color: #fff;
}

.subtitle {
  font-size: 1rem;
  font-weight: 300;
  margin-top: 0.25rem;
  color: var(--secondary-text-color);
}

main {
  display: flex;
  gap: 1.5rem;
  align-items: stretch;
}

.main-col {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
  min-width: 0; /* Prevents flexbox overflow */
}

.card {
  background: var(--surface-color);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  padding: 1.5rem;
  display: flex;
  flex-direction: column;
}

.card-content {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
}

.card-header {
  margin-bottom: 1.5rem;
  padding-bottom: 1rem;
  border-bottom: 1px solid var(--border-color);
}

.card-header h2 {
  font-size: 0.8rem;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 1.5px;
  color: var(--secondary-text-color);
}

/* Upload Area */
.upload-area input[type="file"] {
  display: none;
}

.file-input-label {
  display: flex;
  flex-direction: column;
  text-align: center;
  padding: 2rem;
  background-color: #252525;
  border: 2px dashed var(--border-color);
  border-radius: var(--border-radius);
  cursor: pointer;
  transition: all var(--transition-speed) ease;
}

.file-input-label:hover {
  border-color: var(--accent-color);
  background-color: #2a2a2a;
}

.file-label-title {
  font-weight: 500;
  margin-bottom: 0.5rem;
  font-size: 1.1rem;
}

.file-name {
  font-size: 0.85em;
  color: var(--secondary-text-color);
  margin-top: 0.5rem;
  word-break: break-all;
}

/* Controls */
.control-group {
  margin-bottom: 1.5rem;
}

.control-group:last-of-type {
  margin-bottom: 0;
}

.control-group label {
  display: block;
  margin-bottom: 0.75rem;
  font-size: 0.9rem;
  font-weight: 500;
  color: var(--secondary-text-color);
}

select, input[type="text"] {
  width: 100%;
  padding: 0.7rem 1rem;
  border: 1px solid var(--border-color);
  background-color: #252525;
  border-radius: var(--border-radius);
  font-family: inherit;
  font-size: 0.9rem;
  color: var(--primary-text-color);
  transition: border-color var(--transition-speed) ease;
}

input[type="text"] {
    margin-bottom: 0.5rem;
}

select {
  appearance: none;
  background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23888' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
  background-repeat: no-repeat;
  background-position: right 0.7rem center;
  background-size: 1em;
  cursor: pointer;
}

select:hover {
  border-color: var(--secondary-text-color);
}

.slider-wrapper {
  display: flex;
  align-items: center;
  gap: 10px;
}

input[type="range"] {
  -webkit-appearance: none;
  appearance: none;
  width: 100%;
  height: 4px;
  background: #333;
  border-radius: 2px;
  outline: none;
  padding: 0;
  cursor: pointer;
  flex-grow: 1;
}

input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 16px;
  height: 16px;
  background: var(--primary-text-color);
  border-radius: 50%;
  cursor: pointer;
  transition: background var(--transition-speed);
}

input[type="range"]::-webkit-slider-thumb:hover {
  background: #fff;
}

input[type="range"]::-moz-range-thumb {
  width: 16px;
  height: 16px;
  background: var(--primary-text-color);
  border-radius: 50%;
  cursor: pointer;
  border: none;
  transition: background var(--transition-speed);
}

input[type="range"]::-moz-range-thumb:hover {
  background: #fff;
}

.slider-label {
  font-size: 0.9em;
  color: var(--primary-text-color);
  min-width: 45px;
  text-align: right;
  font-weight: 500;
}

.action-buttons {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  margin-top: auto;
  padding-top: 1.5rem;
}

.btn {
  background: var(--interactive-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  padding: 0.7rem 1.25rem;
  font-family: inherit;
  font-weight: 500;
  font-size: 0.9em;
  color: var(--primary-text-color);
  cursor: pointer;
  transition: all var(--transition-speed) ease;
  flex-grow: 1;
}

.btn:hover:not(:disabled) {
  background-color: var(--interactive-hover);
  border-color: #555;
}

.btn.btn-primary {
  background-color: var(--accent-color);
  border-color: var(--accent-color);
  color: #fff;
}

.btn.btn-primary:hover:not(:disabled) {
  background-color: #0056b3;
  border-color: #0056b3;
}

.btn:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.btn-group {
    display: flex;
    gap: 0.5rem;
}

.order-btn {
    flex: 1;
    font-size: 0.8em;
    padding: 0.6rem 0.5rem;
}

.order-btn.active {
    background-color: var(--accent-color);
    border-color: var(--accent-color);
    color: #fff;
}

/* Waveform */
.waveform-container {
  margin-bottom: 1.5rem;
}

.waveform-container:last-child {
  margin-bottom: 0;
}

.waveform-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.75rem;
}

.waveform-header h3 {
  font-weight: 500;
  color: var(--secondary-text-color);
  font-size: 0.8rem;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.play-button {
  background: transparent;
  border: 1px solid var(--border-color);
  width: 32px;
  height: 32px;
  border-radius: 50%;
  cursor: pointer;
  color: var(--secondary-text-color);
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all var(--transition-speed) ease;
  position: relative;
}

.play-button::after {
  content: "";
  display: block;
  width: 0;
  height: 0;
  border-style: solid;
  border-width: 6px 0 6px 10px;
  border-color: transparent transparent transparent var(--secondary-text-color);
  transform: translateX(1px);
  transition: all var(--transition-speed) ease;
}

.play-button.playing::after {
  border-style: double;
  border-width: 0 0 0 10px;
  height: 12px;
  transform: translateX(0);
  border-color: transparent transparent transparent var(--secondary-text-color);
}

.play-button:hover:not(:disabled) {
  border-color: var(--accent-color);
}

.play-button:hover:not(:disabled)::after {
  border-color: transparent transparent transparent var(--accent-color);
}

.play-button:disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

.canvas-wrapper {
  position: relative;
  background-color: #111;
  border: 1px solid #000;
  border-radius: var(--border-radius);
  overflow: hidden;
  cursor: pointer;
}

canvas {
  width: 100%;
  height: 120px;
  display: block;
}

.playhead {
  position: absolute;
  top: 0;
  left: 0;
  width: 2px;
  height: 100%;
  background-color: var(--accent-color);
  pointer-events: none;
  display: none;
  z-index: 10;
}

.playhead.active {
  display: block;
}

/* Status */
.status {
  margin-top: 1rem;
  padding: 0.75rem;
  background: #252525;
  border-radius: var(--border-radius);
  border: 1px solid var(--border-color);
  font-size: 0.85em;
  color: var(--secondary-text-color);
  text-align: center;
  min-height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.status.error {
  color: #ff6b6b;
  border-color: #ff6b6b;
}

.status.success {
  color: #51cf66;
  border-color: #51cf66;
}

@media (max-width: 1200px) {
  main {
    flex-direction: column;
  }
}
</style>
</head>
<body>
<div class="container">
  <header>
    <h1>NOISE FORGE</h1>
    <p class="subtitle">Lo-Fi Degradation Playground</p>
  </header>
  
  <main>
    <!-- === COLUMN 1: I/O & WAVEFORMS === -->
    <div class="main-col">
      <div class="card">
        <div class="card-header">
          <h2>Input</h2>
        </div>
        <div class="card-content">
          <div class="upload-area">
            <input type="file" id="fileInput" accept="audio/*">
            <label for="fileInput" class="file-input-label">
              <span class="file-label-title">üìÅ Upload Audio</span>
              <span class="file-name" id="fileName">WAV or MP3</span>
            </label>
          </div>
        </div>
      </div>
      <div class="card">
        <div class="card-header">
          <h2>Waveforms</h2>
        </div>
        <div class="card-content">
          <div class="waveform-container">
            <div class="waveform-header">
              <h3>Original</h3>
              <button class="play-button" id="playOriginal" disabled></button>
            </div>
            <div class="canvas-wrapper" id="wrapperOriginal">
              <canvas id="originalWaveform"></canvas>
              <div class="playhead" id="playheadOriginal"></div>
            </div>
          </div>
          <div class="waveform-container">
            <div class="waveform-header">
              <h3>Processed</h3>
              <button class="play-button" id="playProcessed" disabled></button>
            </div>
            <div class="canvas-wrapper" id="wrapperProcessed">
              <canvas id="processedWaveform"></canvas>
              <div class="playhead" id="playheadProcessed"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- === COLUMN 2: DEGRADATION & DISTORTION === -->
    <div class="main-col">
      <div class="card">
        <div class="card-header">
          <h2>Degradation</h2>
        </div>
        <div class="card-content">
          <div class="control-group">
            <label for="algorithm">Algorithm</label>
            <select id="algorithm">
              <option value="am">AM Modulator</option>
              <option value="fm">FM Drifter</option>
              <option value="spec">Spectrogram Crush</option>
              <option value="midi">MIDI Morph</option>
              <option value="base64">Base64 Bloat</option>
              <option value="json">JSON Jam</option>
              <option value="ascii">ASCII Wave</option>
              <option value="qr">QR Code Squeeze</option>
              <option value="svg">SVG Etch</option>
              <option value="hex">Hex to Font</option>
              <option value="csv">CSV Scatter</option>
              <option value="emoji">Emoji Pulse</option>
              <option value="pcm">Raw PCM (Bitcrush)</option>
              <option value="mp3">MP3 Crush (Simulated)</option>
              <option value="ogg">OGG Crunch (Simulated)</option>
              <option value="aiff">AIFF Endian Swap (Simulated)</option>
              <option value="aac">AAC Fizz (Simulated)</option>
              <option value="mod">MOD Resampler</option>
              <option value="sysex">SYSEX Warp</option>
              <option value="vhs">VHS Warp</option>
              <option value="cassette">Cassette Flutter</option>
              <option value="telephone">Telephone Line</option>
              <option value="packetloss">Packet Loss Glitch</option>
              <option value="jpeg">JPEG Artifact</option>
              <option value="bitrot">Bit Rot</option>
              <option value="vinyl">Vinyl Crackle</option>
            </select>
          </div>
          <div class="control-group">
            <label for="intensity">Intensity</label>
            <div class="slider-wrapper">
              <input type="range" id="intensity" min="0" max="100" value="50">
              <span class="slider-label" id="intensityValue">50%</span>
            </div>
          </div>
        </div>
      </div>
      <div class="card">
        <div class="card-header">
            <h2>Distortion</h2>
        </div>
        <div class="card-content">
            <div class="control-group">
                <label for="distortionType">Type</label>
                <select id="distortionType">
                    <option value="none">None</option>
                    <option value="overdrive">Gritty Overdrive</option>
                    <option value="fuzz">Fuzz Buzz</option>
                    <option value="foldback">Foldback</option>
                    <option value="sine">Sine Warp</option>
                    <option value="bitwise">Bitwise Annihilator</option>
                    <option value="chaos">Chaotic Driver</option>
                </select>
            </div>
            <div class="control-group">
                <label for="distortionAmount">Amount</label>
                <div class="slider-wrapper">
                    <input type="range" id="distortionAmount" min="0" max="100" value="0">
                    <span class="slider-label" id="distortionValue">0%</span>
                </div>
            </div>
        </div>
    </div>
    </div>

    <!-- === COLUMN 3: FILTERS, FX & ACTIONS === -->
    <div class="main-col">
        <div class="card">
            <div class="card-header">
              <h2>Filters</h2>
            </div>
            <div class="card-content">
                <div class="control-group">
                    <label for="filterType">Type</label>
                    <select id="filterType">
                        <option value="classic">Classic EQ</option>
                        <option value="comb">Comb Filter</option>
                        <option value="vowel">Vowel Morph</option>
                    </select>
                </div>
                <div id="classicFilterControls">
                    <div class="control-group">
                        <label for="lowpassCutoff">Low-Pass Cutoff</label>
                        <div class="slider-wrapper">
                            <input type="range" id="lowpassCutoff" min="0" max="1000" value="1000">
                            <span class="slider-label" id="lowpassValue">22kHz</span>
                        </div>
                    </div>
                    <div class="control-group">
                        <label for="highpassCutoff">High-Pass Cutoff</label>
                        <div class="slider-wrapper">
                            <input type="range" id="highpassCutoff" min="0" max="1000" value="0">
                            <span class="slider-label" id="highpassValue">20Hz</span>
                        </div>
                    </div>
                </div>
                <div id="weirdFilterControls" style="display: none;">
                     <div class="control-group">
                        <label for="filterAmount">Amount</label>
                        <div class="slider-wrapper">
                            <input type="range" id="filterAmount" min="0" max="100" value="50">
                            <span class="slider-label" id="filterAmountValue">50%</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
         <div class="card">
            <div class="card-header">
              <h2>Playback FX</h2>
            </div>
            <div class="card-content">
                <div class="control-group">
                    <label for="playbackType">Algorithm</label>
                     <select id="playbackType">
                        <option value="tape">Tape (Live)</option>
                        <option value="granular">Granular Freeze</option>
                        <option value="reverse_stutter">Reverse Stutter</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="playbackAmount" id="playbackAmountLabel">Rate</label>
                    <div class="slider-wrapper">
                        <input type="range" id="playbackAmount" min="0" max="100" value="50">
                        <span class="slider-label" id="playbackAmountValue">1.00x</span>
                    </div>
                </div>
            </div>
        </div>
        <div class="card">
            <div class="card-header">
                <h2>Actions</h2>
            </div>
            <div class="card-content">
                <div class="control-group">
                    <label>Effect Order</label>
                    <div class="btn-group">
                        <button id="orderDegradeFirst" class="btn order-btn active">Process ‚Üí Filter</button>
                        <button id="orderFilterFirst" class="btn order-btn">Filter ‚Üí Process</button>
                    </div>
                </div>
                 <div class="control-group">
                    <label>Presets</label>
                    <select id="presetList"></select>
                    <div class="btn-group" style="margin-top: 0.5rem;">
                         <button id="deletePresetBtn" class="btn" disabled>Delete</button>
                    </div>
                    <div class="btn-group" style="margin-top: 0.5rem;">
                         <input type="text" id="presetName" placeholder="New Preset Name...">
                         <button id="savePresetBtn" class="btn">Save</button>
                    </div>
                </div>
                <div class="action-buttons">
                    <button id="processBtn" class="btn btn-primary" disabled>Process</button>
                    <div class="btn-group">
                        <button id="resampleBtn" class="btn" disabled>Resample</button>
                        <button id="downloadBtn" class="btn" disabled>Download</button>
                    </div>
                </div>
                <div class="status" id="status">Ready</div>
            </div>
        </div>
    </div>
  </main>
</div>

<script>
// === DOM ELEMENTS ===
const fileInput = document.getElementById('fileInput');
const fileName = document.getElementById('fileName');
const algorithmSelect = document.getElementById('algorithm');
const intensitySlider = document.getElementById('intensity');
const intensityValue = document.getElementById('intensityValue');
const processBtn = document.getElementById('processBtn');
const downloadBtn = document.getElementById('downloadBtn');
const resampleBtn = document.getElementById('resampleBtn');
const status = document.getElementById('status');
const originalCanvas = document.getElementById('originalWaveform');
const processedCanvas = document.getElementById('processedWaveform');
const wrapperOriginal = document.getElementById('wrapperOriginal');
const wrapperProcessed = document.getElementById('wrapperProcessed');
const playOriginal = document.getElementById('playOriginal');
const playProcessed = document.getElementById('playProcessed');
const playheadOriginal = document.getElementById('playheadOriginal');
const playheadProcessed = document.getElementById('playheadProcessed');
const distortionTypeSelect = document.getElementById('distortionType');
const distortionAmountSlider = document.getElementById('distortionAmount');
const distortionValue = document.getElementById('distortionValue');
const filterTypeSelect = document.getElementById('filterType');
const classicFilterControls = document.getElementById('classicFilterControls');
const weirdFilterControls = document.getElementById('weirdFilterControls');
const filterAmountSlider = document.getElementById('filterAmount');
const filterAmountValue = document.getElementById('filterAmountValue');
const lowpassSlider = document.getElementById('lowpassCutoff');
const lowpassValue = document.getElementById('lowpassValue');
const highpassSlider = document.getElementById('highpassCutoff');
const highpassValue = document.getElementById('highpassValue');
const orderDegradeFirstBtn = document.getElementById('orderDegradeFirst');
const orderFilterFirstBtn = document.getElementById('orderFilterFirst');
const playbackTypeSelect = document.getElementById('playbackType');
const playbackAmountSlider = document.getElementById('playbackAmount');
const playbackAmountValue = document.getElementById('playbackAmountValue');
const playbackAmountLabel = document.getElementById('playbackAmountLabel');
const presetList = document.getElementById('presetList');
const presetNameInput = document.getElementById('presetName');
const savePresetBtn = document.getElementById('savePresetBtn');
const deletePresetBtn = document.getElementById('deletePresetBtn');

// === STATE VARIABLES ===
let audioContext;
let originalBuffer;
let processedBuffer;
let currentSource = null;
let currentPlayhead = null;
let currentPlayButton = null;
let animationId = null;
let effectOrder = 'degrade_first';
let playbackStartTime = 0;
let startOffset = 0;
let presets = {};
const minFilterFreq = 20;
const maxFilterFreq = 22000;

// === INITIALIZATION ===
function init() {
  resizeCanvases();
  loadPresetsFromStorage();
  addEventListeners();
  resetAllControls();
}

function resizeCanvases() {
  [originalCanvas, processedCanvas].forEach(canvas => {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = canvas.parentElement.offsetWidth * dpr;
    canvas.height = canvas.parentElement.offsetHeight * dpr;
    const ctx = canvas.getContext('2d');
    ctx.scale(dpr, dpr);
  });
  if (originalBuffer) drawWaveform(originalCanvas, originalBuffer);
  if (processedBuffer) drawWaveform(processedCanvas, processedBuffer);
}

// === EVENT LISTENERS ===
function addEventListeners() {
    window.addEventListener('resize', resizeCanvases);

    // Sliders
    intensitySlider.addEventListener('input', () => { intensityValue.textContent = `${intensitySlider.value}%`; });
    distortionAmountSlider.addEventListener('input', () => { distortionValue.textContent = `${distortionAmountSlider.value}%`; });
    lowpassSlider.addEventListener('input', () => updateFilterLabel(lowpassValue, linToLogFreq(lowpassSlider.value)));
    highpassSlider.addEventListener('input', () => updateFilterLabel(highpassValue, linToLogFreq(highpassSlider.value)));
    filterAmountSlider.addEventListener('input', () => { filterAmountValue.textContent = `${filterAmountSlider.value}%`; });

    // Buttons
    orderDegradeFirstBtn.addEventListener('click', () => setEffectOrder('degrade_first'));
    orderFilterFirstBtn.addEventListener('click', () => setEffectOrder('filter_first'));
    fileInput.addEventListener('change', handleFileUpload);
    processBtn.addEventListener('click', processAudio);
    downloadBtn.addEventListener('click', downloadAudio);
    resampleBtn.addEventListener('click', resampleAudio);
    playOriginal.addEventListener('click', () => togglePlayback(originalBuffer, playOriginal, playheadOriginal));
    playProcessed.addEventListener('click', () => togglePlayback(processedBuffer, playProcessed, playheadProcessed));
    
    // UI Change Handlers
    filterTypeSelect.addEventListener('change', updateFilterUI);
    playbackTypeSelect.addEventListener('change', updatePlaybackUI);
    playbackAmountSlider.addEventListener('input', updatePlaybackUI);

    // Presets
    savePresetBtn.addEventListener('click', savePreset);
    deletePresetBtn.addEventListener('click', deletePreset);
    presetList.addEventListener('change', loadPreset);

    // Scrubbing
    wrapperOriginal.addEventListener('mousedown', (e) => handleScrub(e, originalBuffer, playOriginal, playheadOriginal));
    wrapperProcessed.addEventListener('mousedown', (e) => handleScrub(e, processedBuffer, playProcessed, playheadProcessed));

    // Keyboard Shortcuts
    document.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
            e.preventDefault();
            const targetButton = playProcessed.disabled ? playOriginal : playProcessed;
            if (!targetButton.disabled) targetButton.click();
        }
        if (e.code === 'Enter' && e.target.tagName !== 'INPUT') {
            e.preventDefault();
            if (!processBtn.disabled) processBtn.click();
        }
    });
}

// === CORE LOGIC ===

function setEffectOrder(order) {
    effectOrder = order;
    orderDegradeFirstBtn.classList.toggle('active', order === 'degrade_first');
    orderFilterFirstBtn.classList.toggle('active', order !== 'degrade_first');
}

async function handleFileUpload(e) {
  const file = e.target.files[0];
  if (!file) return;
  
  fileName.textContent = file.name;
  
  try {
    updateStatus('Loading audio...', '');
    if (!audioContext) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
    const arrayBuffer = await file.arrayBuffer();
    originalBuffer = await audioContext.decodeAudioData(arrayBuffer);
    processedBuffer = null;
    
    drawWaveform(originalCanvas, originalBuffer);
    clearCanvas(processedCanvas);
    
    processBtn.disabled = false;
    downloadBtn.disabled = true;
    resampleBtn.disabled = true;
    playOriginal.disabled = false;
    playProcessed.disabled = true;
    
    updateStatus('Audio loaded successfully', 'success');
  } catch (err) {
    updateStatus(`Error: ${err.message}`, 'error');
  }
}

async function processAudio() {
  if (!originalBuffer) return;

  try {
    updateStatus('Processing...', '');
    processBtn.disabled = true;
    
    await new Promise(resolve => setTimeout(resolve, 50));

    // 1. Apply destructive playback FX first
    let bufferAfterPlaybackFX = await applyPlaybackFX(originalBuffer);

    // 2. Apply degradation
    let degradedBuffer = await applyAlgorithm(bufferAfterPlaybackFX, algorithmSelect.value, intensitySlider.value / 100);

    // 3. Setup offline context for node-based processing
    const offlineCtx = new OfflineAudioContext(degradedBuffer.numberOfChannels, degradedBuffer.length, degradedBuffer.sampleRate);
    const sourceNode = offlineCtx.createBufferSource();
    sourceNode.buffer = degradedBuffer;

    // 4. Create processing nodes
    const distortionNode = createDistortionNode(offlineCtx);
    const filterGraph = createFilterGraph(offlineCtx);

    // 5. Connect nodes based on effect order
    if (effectOrder === 'degrade_first') {
        sourceNode.connect(distortionNode).connect(filterGraph.input);
        filterGraph.output.connect(offlineCtx.destination);
    } else {
        sourceNode.connect(filterGraph.input);
        filterGraph.output.connect(distortionNode).connect(offlineCtx.destination);
    }
    
    sourceNode.start(0);
    processedBuffer = await offlineCtx.startRendering();

    drawWaveform(processedCanvas, processedBuffer);
    
    downloadBtn.disabled = false;
    resampleBtn.disabled = false;
    playProcessed.disabled = false;
    
    updateStatus('Processing complete', 'success');
  } catch (err) {
    console.error(err);
    updateStatus(`Error: ${err.message}`, 'error');
  } finally {
    processBtn.disabled = false;
  }
}

function resampleAudio() {
    if (!processedBuffer) return;
    stopAudio();
    originalBuffer = processedBuffer;
    processedBuffer = null;
    drawWaveform(originalCanvas, originalBuffer);
    clearCanvas(processedCanvas);
    playProcessed.disabled = true;
    downloadBtn.disabled = true;
    resampleBtn.disabled = true;
    updateStatus('Resampled to input', 'success');
}

function downloadAudio() {
  if (!processedBuffer) return;
  const wav = bufferToWav(processedBuffer);
  const blob = new Blob([wav], { type: 'audio/wav' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `noiseforge_${algorithmSelect.value}_${Date.now()}.wav`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  updateStatus('Download started', 'success');
}

// === PRESET MANAGEMENT ===

function savePreset() {
    const name = presetNameInput.value.trim();
    if (!name) { updateStatus('Please enter a preset name.', 'error'); return; }
    presets[name] = {
        algorithm: algorithmSelect.value,
        intensity: intensitySlider.value,
        distortionType: distortionTypeSelect.value,
        distortionAmount: distortionAmountSlider.value,
        filterType: filterTypeSelect.value,
        lowpass: lowpassSlider.value,
        highpass: highpassSlider.value,
        filterAmount: filterAmountSlider.value,
        playbackType: playbackTypeSelect.value,
        playbackAmount: playbackAmountSlider.value,
        order: effectOrder,
    };
    localStorage.setItem('noiseForgePresets', JSON.stringify(presets));
    populatePresetList();
    presetList.value = name;
    presetNameInput.value = '';
    updateStatus(`Preset '${name}' saved.`, 'success');
}

function loadPreset() {
    const name = presetList.value;
    if (name === "__init__") {
        resetAllControls();
        updateStatus('Controls reset to default.', 'success');
        return;
    }
    if (!name || !presets[name]) return;
    const p = presets[name];
    
    algorithmSelect.value = p.algorithm;
    intensitySlider.value = p.intensity;
    distortionTypeSelect.value = p.distortionType;
    distortionAmountSlider.value = p.distortionAmount;
    filterTypeSelect.value = p.filterType;
    lowpassSlider.value = p.lowpass;
    highpassSlider.value = p.highpass;
    filterAmountSlider.value = p.filterAmount;
    playbackTypeSelect.value = p.playbackType;
    playbackAmountSlider.value = p.playbackAmount;
    setEffectOrder(p.order);

    // Update all UI labels and states from the new values
    intensityValue.textContent = `${p.intensity}%`;
    distortionValue.textContent = `${p.distortionAmount}%`;
    updateFilterUI();
    updatePlaybackUI();
    
    updateStatus(`Preset '${name}' loaded.`, 'success');
}

function deletePreset() {
    const name = presetList.value;
    if (!name || name === "__init__" || !presets[name]) return;
    if (confirm(`Are you sure you want to delete the preset '${name}'?`)) {
        delete presets[name];
        localStorage.setItem('noiseForgePresets', JSON.stringify(presets));
        populatePresetList();
        updateStatus(`Preset '${name}' deleted.`, 'success');
    }
}

function loadPresetsFromStorage() {
    const storedPresets = localStorage.getItem('noiseForgePresets');
    if (storedPresets) presets = JSON.parse(storedPresets);
    populatePresetList();
}

function populatePresetList() {
    const currentVal = presetList.value;
    presetList.innerHTML = '<option value="__init__">-- Initial State --</option>';
    Object.keys(presets).sort().forEach(name => {
        const option = document.createElement('option');
        option.value = name;
        option.textContent = name;
        presetList.appendChild(option);
    });
    presetList.value = currentVal;
    deletePresetBtn.disabled = !presetList.value || presetList.value === "__init__";
}

function resetAllControls() {
    algorithmSelect.selectedIndex = 0;
    intensitySlider.value = 50;
    distortionTypeSelect.selectedIndex = 0;
    distortionAmountSlider.value = 0;
    filterTypeSelect.selectedIndex = 0;
    lowpassSlider.value = 1000;
    highpassSlider.value = 0;
    filterAmountSlider.value = 50;
    playbackTypeSelect.selectedIndex = 0;
    playbackAmountSlider.value = 50; // Corresponds to 1.0x rate
    setEffectOrder('degrade_first');

    intensityValue.textContent = "50%";
    distortionValue.textContent = "0%";
    updateFilterUI();
    updatePlaybackUI();
}

// === PLAYBACK & SCRUBBING ===

function togglePlayback(buffer, button, playhead) {
    if (!buffer) return;
    if (button.classList.contains('playing')) stopAudio();
    else playAudio(buffer, button, playhead, startOffset);
}

function playAudio(buffer, button, playhead, offset = 0) {
  if (currentSource) stopAudio();

  currentSource = audioContext.createBufferSource();
  currentSource.buffer = buffer;
  
  if (playbackTypeSelect.value === 'tape') {
    const rate = 0.5 + (playbackAmountSlider.value / 100) * 1.5;
    currentSource.playbackRate.value = rate;
  }
  
  currentSource.connect(audioContext.destination);
  
  startOffset = offset;
  playbackStartTime = audioContext.currentTime - (startOffset / currentSource.playbackRate.value);
  currentSource.start(0, startOffset);
  
  button.classList.add('playing');
  playhead.classList.add('active');
  currentPlayhead = playhead;
  currentPlayButton = button;
  
  updatePlayheadPosition();
  
  currentSource.onended = () => { if (currentPlayButton === button) stopAudio(true); };
}

function stopAudio(finished = false) {
  if (currentSource) {
    currentSource.onended = null;
    startOffset = finished ? 0 : (audioContext.currentTime - playbackStartTime) * currentSource.playbackRate.value;
    try { currentSource.stop(); } catch (e) {}
    currentSource = null;
  }
  
  if (animationId) cancelAnimationFrame(animationId);
  animationId = null;
  if (currentPlayButton) currentPlayButton.classList.remove('playing');
  if (currentPlayhead) {
    if (finished) currentPlayhead.style.left = '0%';
    currentPlayhead.classList.remove('active');
  }
  currentPlayhead = null;
  currentPlayButton = null;
}

function updatePlayheadPosition() {
    if (!currentSource) return;
    const rate = currentSource.playbackRate.value;
    const effectiveDuration = currentSource.buffer.duration / rate;
    const elapsed = audioContext.currentTime - playbackStartTime;
    if (elapsed >= effectiveDuration) return;
    if(currentPlayhead) {
        const progress = (elapsed * rate) / currentSource.buffer.duration;
        currentPlayhead.style.left = `${progress * 100}%`;
    }
    animationId = requestAnimationFrame(updatePlayheadPosition);
}

function handleScrub(event, buffer, button, playhead) {
    if (!buffer) return;
    const rect = event.currentTarget.getBoundingClientRect();
    const wasPlaying = button.classList.contains('playing');

    const calculateAndSeek = (e) => {
        const x = e.clientX - rect.left;
        const percentage = Math.max(0, Math.min(1, x / rect.width));
        startOffset = buffer.duration * percentage;
        playhead.style.left = `${percentage * 100}%`;
        if (wasPlaying) playAudio(buffer, button, playhead, startOffset);
    };
    calculateAndSeek(event);
    const mouseMoveHandler = (e) => calculateAndSeek(e);
    const mouseUpHandler = () => {
        window.removeEventListener('mousemove', mouseMoveHandler);
        window.removeEventListener('mouseup', mouseUpHandler);
    };
    window.addEventListener('mousemove', mouseMoveHandler);
    window.addEventListener('mouseup', mouseUpHandler);
}

// === UI & DRAWING & HELPERS ===

function updateFilterUI() {
    const isClassic = filterTypeSelect.value === 'classic';
    classicFilterControls.style.display = isClassic ? 'block' : 'none';
    weirdFilterControls.style.display = isClassic ? 'none' : 'block';
    updateFilterLabel(lowpassValue, linToLogFreq(lowpassSlider.value));
    updateFilterLabel(highpassValue, linToLogFreq(highpassSlider.value));
    filterAmountValue.textContent = `${filterAmountSlider.value}%`;
}

function updatePlaybackUI() {
    const type = playbackTypeSelect.value;
    const amount = playbackAmountSlider.value / 100.0;
    let labelText = '';
    let valueText = '';
    
    switch(type) {
        case 'tape':
            const rate = 0.5 + amount * 1.5;
            labelText = 'Rate';
            valueText = `${rate.toFixed(2)}x`;
            if (currentSource) currentSource.playbackRate.value = rate;
            break;
        case 'granular':
            labelText = 'Grain Position';
            valueText = `${Math.round(amount * 100)}%`;
            break;
        case 'reverse_stutter':
            labelText = 'Chunk Size';
            valueText = `${Math.round(amount * 100)}%`;
            break;
    }
    playbackAmountLabel.textContent = labelText;
    playbackAmountValue.textContent = valueText;
}

function updateStatus(message, type = '') { status.textContent = message; status.className = `status ${type}`; }
function updateFilterLabel(el, freq) { el.textContent = freq < 1000 ? `${Math.round(freq)}Hz` : `${(freq/1000).toFixed(1)}kHz`; }
function linToLogFreq(v) { return minFilterFreq * Math.pow(maxFilterFreq / minFilterFreq, v / 1000.0); }
function freqToLinValue(f) { return Math.round((Math.log(f / minFilterFreq) / Math.log(maxFilterFreq / minFilterFreq)) * 1000); }

function drawWaveform(canvas, buffer) {
  const ctx = canvas.getContext('2d'), W = canvas.parentElement.offsetWidth, H = canvas.parentElement.offsetHeight;
  const data = buffer.getChannelData(0);
  ctx.clearRect(0, 0, W, H); ctx.fillStyle = '#111'; ctx.fillRect(0, 0, W, H);
  ctx.strokeStyle = '#007bff'; ctx.lineWidth = 1.5; ctx.beginPath();
  const step = Math.ceil(data.length / W), amp = H / 2;
  for (let i = 0; i < W; i++) {
    let min = 1, max = -1;
    for (let j = 0; j < step; j++) {
      const d = data[(i * step) + j];
      if (d !== undefined) { if (d < min) min = d; if (d > max) max = d; }
    }
    ctx.moveTo(i, (1 + min) * amp); ctx.lineTo(i, (1 + max) * amp);
  }
  ctx.stroke();
  ctx.strokeStyle = '#2c2c2c'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0, H / 2); ctx.lineTo(W, H / 2); ctx.stroke();
}

function clearCanvas(canvas) {
  const ctx = canvas.getContext('2d'), W = canvas.parentElement.offsetWidth, H = canvas.parentElement.offsetHeight;
  ctx.fillStyle = '#111'; ctx.fillRect(0, 0, W, H);
}

// === ALGORITHMS & PROCESSING NODES ===

function createFilterGraph(context) {
    const type = filterTypeSelect.value;
    const input = context.createGain();
    const output = context.createGain();

    if (type === 'classic') {
        const highpass = context.createBiquadFilter();
        highpass.type = 'highpass';
        highpass.frequency.value = linToLogFreq(highpassSlider.value);
        highpass.Q.value = 0.7071;
        const lowpass = context.createBiquadFilter();
        lowpass.type = 'lowpass';
        lowpass.frequency.value = linToLogFreq(lowpassSlider.value);
        lowpass.Q.value = 0.7071;
        input.connect(highpass).connect(lowpass).connect(output);
    } else if (type === 'comb') {
        const amount = filterAmountSlider.value / 100.0;
        const delayTime = 0.001 + amount * 0.05; // 1ms to 50ms
        const feedback = 0.1 + amount * 0.85;
        const delay = context.createDelay(0.1);
        delay.delayTime.value = delayTime;
        const feedbackGain = context.createGain();
        feedbackGain.gain.value = feedback;
        input.connect(delay);
        delay.connect(feedbackGain);
        feedbackGain.connect(delay);
        input.connect(output); // Dry signal
        delay.connect(output); // Wet signal
    } else if (type === 'vowel') {
        // Simple vowel morph A-E-I-O-U
        const amount = filterAmountSlider.value / 100.0;
        const formants = [
            { f: [660, 1720, 2410], q: [6, 8, 12] }, // A
            { f: [520, 1840, 2480], q: [5, 9, 12] }, // E
            { f: [270, 2290, 3010], q: [4, 10, 15] },// I
            { f: [450, 870, 2410], q: [5, 7, 12] },  // O
            { f: [300, 870, 2240], q: [4, 7, 12] },  // U
        ];
        const numVowels = formants.length;
        const pos = amount * (numVowels - 1);
        const idx1 = Math.floor(pos);
        const idx2 = Math.min(numVowels - 1, idx1 + 1);
        const frac = pos - idx1;

        for (let i = 0; i < 3; i++) {
            const f1 = formants[idx1].f[i], q1 = formants[idx1].q[i];
            const f2 = formants[idx2].f[i], q2 = formants[idx2].q[i];
            const freq = f1 + (f2 - f1) * frac;
            const q = q1 + (q2 - q1) * frac;

            const bandpass = context.createBiquadFilter();
            bandpass.type = 'bandpass';
            bandpass.frequency.value = freq;
            bandpass.Q.value = q;
            input.connect(bandpass).connect(output);
        }
    }
    return { input, output };
}

function createDistortionNode(context) {
    const type = distortionTypeSelect.value, amount = distortionAmountSlider.value / 100;
    if (type === 'none' || amount === 0) return context.createGain();
    const dist = context.createWaveShaper(), curve = new Float32Array(4096);
    switch (type) {
        case 'overdrive': { const k = amount*100; for(let i=0;i<4096;i++){const x=i*2/4096-1;curve[i]=((1+k/25)*x)/(1+(k/25)*Math.abs(x))}}break;
        case 'fuzz': { const k=amount*100; for(let i=0;i<4096;i++){const x=i*2/4096-1,y=x*(k+1);curve[i]=(y>0?1:-1)*(1-Math.exp(-Math.abs(y)))}}break;
        case 'foldback': for(let i=0;i<4096;i++){const x=i*2/4096-1,th=1-(amount*.9);curve[i]=Math.max(-1,Math.min(1,x-(Math.max(0,x-th)*2)+(Math.min(0,x+th)*2)))}break;
        case 'sine':{const k=amount*10;for(let i=0;i<4096;i++){const x=i*2/4096-1;curve[i]=Math.sin(x*(1+k)*Math.PI/2)}}break;
        case 'bitwise': {const mask=Math.floor(amount*255);for(let i=0;i<4096;i++){const x=i*2/4096-1,y=Math.floor((x+1)*127.5);curve[i]=((y^mask)/127.5)-1}}break;
        case 'chaos': { const r=3.57+(amount*0.429); let y=.5; for(let i=0;i<4096;i++){y=r*y*(1-y);curve[i]=(y-0.5)*2}}break;
    }
    dist.curve = curve;
    dist.oversample = '4x';
    return dist;
}

async function applyPlaybackFX(buffer) {
    const type = playbackTypeSelect.value;
    const amount = playbackAmountSlider.value / 100.0;
    if (type === 'tape') return buffer; // Tape is live, not destructive

    const newBuffer = audioContext.createBuffer(buffer.numberOfChannels, buffer.length, buffer.sampleRate);
    for(let ch=0; ch < buffer.numberOfChannels; ch++) {
        const input = buffer.getChannelData(ch);
        const output = newBuffer.getChannelData(ch);
        switch (type) {
            case 'granular': {
                const grainPos = Math.floor(amount * (input.length - 1));
                const grainSize = Math.floor(0.01 * buffer.sampleRate); // 10ms grain
                for(let i=0; i < output.length; i++) {
                    const idx = (grainPos + (i % grainSize)) % input.length;
                    output[i] = input[idx];
                }
                break;
            }
            case 'reverse_stutter': {
                const chunkSize = Math.floor((0.01 + amount * 0.5) * buffer.sampleRate);
                for(let i=0; i < output.length; i += chunkSize) {
                    for(let j=0; j < chunkSize; j++) {
                        if (i + j < output.length) {
                            const readIdx = i + (chunkSize - 1 - j);
                            output[i + j] = readIdx < input.length ? input[readIdx] : 0;
                        }
                    }
                }
                break;
            }
        }
    }
    return newBuffer;
}

async function applyAlgorithm(buffer, algo, intensity) {
  const newBuffer = audioContext.createBuffer(buffer.numberOfChannels, buffer.length, buffer.sampleRate);
  for (let ch = 0; ch < buffer.numberOfChannels; ch++) {
    const input = buffer.getChannelData(ch), output = newBuffer.getChannelData(ch);
    if (algo === 'base64') { base64Bloat(input, output, intensity); continue; }
    switch (algo) {
      case 'am': amModulator(input, output, intensity); break; case 'fm': fmDrifter(input, output, intensity); break; case 'spec': spectrogramCrush(input, output, intensity); break; case 'midi': midiMorph(input, output, intensity); break; case 'json': jsonJam(input, output, intensity); break; case 'ascii': asciiWave(input, output, intensity); break; case 'qr': qrCodeSqueeze(input, output, intensity); break; case 'svg': svgEtch(input, output, intensity); break; case 'hex': hexToFont(input, output, intensity); break; case 'csv': csvScatter(input, output, intensity); break; case 'emoji': emojiPulse(input, output, intensity); break; case 'pcm': rawPcmBitcrush(input, output, intensity); break; case 'mp3': mp3Crush(input, output, intensity); break; case 'ogg': oggCrunch(input, output, intensity, buffer.sampleRate); break; case 'aiff': aiffEndianSwap(input, output, intensity); break; case 'aac': aacFizz(input, output, intensity); break; case 'mod': modResampler(input, output, intensity); break; case 'sysex': sysexWarp(input, output, intensity); break; case 'vhs': vhsWarp(input, output, intensity, buffer.sampleRate); break; case 'cassette': cassetteFlutter(input, output, intensity); break; case 'telephone': telephoneLine(input, output, intensity); break; case 'packetloss': packetLossGlitch(input, output, intensity); break; case 'jpeg': jpegArtifact(input, output, intensity); break; case 'bitrot': bitRot(input, output, intensity); break; case 'vinyl': vinylCrackle(input, output, intensity); break;
    }
  }
  return newBuffer;
}

// ... All other degradation algorithm functions (minified) remain here...
function base64Bloat(i,o,n){const t=new Uint8Array(i.length);for(let e=0;e<i.length;e++)t[e]=Math.floor(127.5*(i[e]+1));let e="";const s=Math.floor(t.length/(1+n));for(let i=0;i<s;i++)e+=String.fromCharCode(t[i]);try{const t=btoa(e),n=atob(t);for(let e=0;e<o.length;e++){const i=Math.floor(e/o.length*n.length);o[e]=n.length>0?(n.charCodeAt(i%n.length)/127.5-1)*(1-.3*0):0}}catch(t){console.error("Base64 encoding failed, falling back.",t);for(let t=0;t<i.length;t++)o[t]=i[t]}}
function amModulator(i,o,n){const t=50+500*n;for(let e=0;e<i.length;e++){const s=Math.sin(e/t)*(1+2*n),a=(Math.random()-.5)*n*.5;o[e]=Math.tanh(i[e]*s+a)}}
function fmDrifter(i,o,n){let t=0;const e=n*.01;for(let s=0;s<i.length;s++)t+=i[s]*e+Math.random()*n*.001,o[s]=.8*Math.sin(t)}
function spectrogramCrush(i,o,n){const t=Math.floor(32+200*n);for(let e=0;e<i.length;e+=t){let s=0;for(let n=0;n<t&&e+n<i.length;n++)s+=i[e+n];s/=t,s=Math.round(s*(100-90*n))/(100-90*n);for(let a=0;a<t&&e+a<i.length;a++)o[e+a]=s+(Math.random()-.5)*n*.1}}
function midiMorph(i,o,n){for(let t=0;t<i.length;t++){const e=Math.round(63.5*(i[t]+1));o[t]=2*((e+Math.floor(Math.random()*n*12))/127)-1}}
function jsonJam(i,o,n){const t=Math.max(1,Math.floor(50*n)),e=[];for(let s=0;s<i.length;s+=t)e.push(parseFloat(i[s].toFixed(3-Math.floor(2*n))));const s=JSON.stringify(e),a=JSON.parse(s);for(let t=0;t<o.length;t++){const e=Math.floor(t/o.length*a.length);o[t]=a[e]||0}}
function asciiWave(i,o,n){const t=" .-:=+*#%@",e=[];for(let s=0;s<i.length;s+=Math.max(1,Math.floor(10-9*n))){const o=Math.floor(.5*(i[s]+1)*(t.length-1));e.push(t[o])}for(let n=0;n<o.length;n++){const i=Math.floor(n/o.length*e.length),s=t.indexOf(e[i%e.length]);o[n]=2*(s/t.length)-1}}
function qrCodeSqueeze(i,o,n){const t=new Uint8Array(Math.floor(i.length*(1-.7*n)));for(let e=0;e<t.length;e++){const o=Math.floor(e/t.length*i.length);t[e]=Math.floor(127.5*(i[o]+1))}for(let e=0;e<o.length;e++){const t=Math.floor(e/o.length*i.length);o[e]=i[t]/127.5-1+(Math.random()-.5)*n*.3}}
function svgEtch(i,o,n){const t=Math.max(10,Math.floor(i.length/(10+1e3*n))),e=[];for(let s=0;s<t;s++){const o=Math.floor(s/t*i.length);e.push(i[o])}for(let n=0;n<o.length;n++){const i=n/o.length*(e.length-1),t=Math.floor(i),s=i-t,a=e[t]||0,r=e[Math.min(t+1,e.length-1)]||0;o[n]=a+(r-a)*s}}
function hexToFont(i,o,n){const t=Array.from(i).map(i=>Math.floor(127.5*(i+1)).toString(16).padStart(2,"0")).join(""),e=t.slice(0,Math.floor(t.length*(1-.6*n)));for(let i=0;i<o.length;i++){const t=Math.floor(i/o.length*e.length),s=parseInt(e.substr(t%e.length,2),16)||0;o[i]=(s/127.5-1)*(1-.2*n)}}
function csvScatter(i,o,n){const t=[],e=Math.max(1,Math.floor(1+20*n));for(let s=0;s<i.length;s+=e)t.push(i[s].toFixed(4-Math.floor(3*n)));const s=t.join(","),a=s.split(",").map(parseFloat);for(let t=0;t<o.length;t++){const e=Math.floor(t/o.length*a.length);o[t]=a[e]||0}}
function emojiPulse(i,o,n){const t=["üò¥","üòê","üòä","üòÉ","üòÑ","ü§©","üî•","üí•","‚ö°"],e=[];for(let s=0;s<i.length;s+=Math.max(1,Math.floor(10-8*n))){const o=Math.floor(.5*(i[s]+1)*(t.length-1));e.push(t[o])}const s=e.join("");for(let t=0;t<o.length;t++){const e=Math.floor(t/o.length*s.length),a=s.charCodeAt(e%s.length);o[t]=(a%256/127.5-1)*(1-.4*n)}}
function rawPcmBitcrush(i,o,n){const t=16-Math.floor(15*n),e=Math.pow(2,t);for(let s=0;s<i.length;s++){const n=(i[s]+1)/2,t=Math.round(n*(e-1))/(e-1);o[s]=2*t-1}}
function mp3Crush(i,o,n){const t=12-Math.floor(10*n),e=Math.pow(2,t),s=Math.floor(20*n);for(let a=0;a<i.length;a++){let n=0;for(let o=0;o<s;o++)n+=i[Math.max(0,a-o)]||0;n/=s;const r=Math.round(n*e)/e;o[a]=r}}
function oggCrunch(i,o,n,t){const e=.1+8*n,s=t/e;for(let a=0;a<i.length;a++){const t=(Math.sin(a/s*2*Math.PI)+1)/2,e=n*t,r=16-Math.floor(14*e),l=Math.pow(2,r);o[a]=Math.round(i[a]*l)/l}}
function aiffEndianSwap(i,o,n){const t=Math.max(2,Math.floor(80*(1-n)+2));for(let e=0;e<i.length;e+=t)for(let s=0;s<t;s++)e+s<i.length&&(o[e+s]=i[e+(t-1-s)])}
function aacFizz(i,o,n){const t=n*.05,e=Math.floor(50*n);for(let s=0;s<i.length;s++)if(Math.random()<t){for(let n=0;n<e&&s+n<i.length;n++)o[s+n]=2*Math.random()-1;s+=e-1}else o[s]=i[s]}
function modResampler(i,o,n){const t=1+Math.floor(80*n),e=[];for(let s=0;s<i.length;s+=t)e.push(i[s]);const s=8-Math.floor(6*n),a=Math.pow(2,s);for(let i=0;i<e.length;i++)e[i]=Math.round(e[i]*a)/a;for(let n=0;n<o.length;n++){const i=Math.floor(n/t);o[n]=e[Math.min(i,e.length-1)]||0}}
function sysexWarp(i,o,n){const t=[],e=Math.max(1,Math.floor(10-9*n));for(let s=0;s<i.length;s+=e)t.push(Math.floor(63.5*(i[s]+1)));const s=Math.floor(50*n),a=t.map(i=>(i+(Math.random()-.5)*s)%128);for(let n=0;n<o.length;n++){const i=n/o.length*(a.length-1),t=Math.floor(i),e=i-t,s=a[t]||0,r=a[Math.min(t+1,a.length-1)]||0,l=s+(r-s)*e;o[n]=l/63.5-1}}
function vhsWarp(i,o,n,t){const e=.2+4*n,s=t/e,a=Math.floor(150*n),r=n*.05;for(let l=0;l<i.length;l++){const n=Math.sin(l/s*2*Math.PI),t=Math.round(n*a),e=Math.max(0,Math.min(i.length-1,l+t)),c=(Math.random()-.5)*r;o[l]=i[e]+c}}
function cassetteFlutter(i,o,n){let t=0;const e=1-.8*n,s=.005*n;let a=0;for(let r=0;r<i.length;r++){const n=i[r]*e+t*(1-e);t=n,a+=(Math.random()-.5)*s,o[r]=Math.sin(Math.PI*(n+a))}}
function telephoneLine(i,o,n){let t=0,e=0;const s=.9,a=.1,r=4-Math.floor(2*n),l=Math.pow(2,r);for(let c=0;c<i.length;c++){t+=a*(i[c]-t),e=e*s+(1-s)*t;const n=(e+1)/2,h=Math.round(n*(l-1))/(l-1);o[c]=.8*(2*h-1)}}
function packetLossGlitch(i,o,n){const t=n*.01,e=Math.floor(2e3*n);for(let s=0;s<i.length;s++)if(Math.random()<t){const n=Math.floor(Math.random()*e);for(let t=0;t<n&&s+t<i.length;t++)o[s+t]=0;s+=n-1}else o[s]=i[s]}
function jpegArtifact(i,o,n){const t=Math.max(2,Math.floor(200-198*n));for(let e=0;e<i.length;e+=t){let s=0,a=0;for(let o=0;o<t&&e+o<i.length;o++)s+=i[e+o],a++;const r=s/a,l=16-Math.floor(14*n),c=Math.round(r*l)/l;for(let n=0;n<t&&e+n<i.length;n++)o[e+n]=c}}
function bitRot(i,o,n){const t=.1*n,e=.1*n;for(let s=0;s<i.length;s++)o[s]=Math.random()<t?Math.max(-1,Math.min(1,i[s]+(Math.random()-.5)*e)):i[s]}
function vinylCrackle(i,o,n){const t=.02*n,e=.015*n,s=.001*n,a=.2+.8*n;let r=0;for(let l=0;l<i.length;l++){const n=(Math.random()-.5)*t;r+=.01*(Math.random()-.5),r*=.995;let c=0;Math.random()<s&&(c=(.5*Math.random()+.5)*a),o[l]=Math.max(-1,Math.min(1,i[l]+n+r*e+c))}}

// === WAV CONVERSION ===
function bufferToWav(buffer) {
  const numChannels = buffer.numberOfChannels, sampleRate = buffer.sampleRate, bitDepth = 16;
  const bytesPerSample = bitDepth / 8, blockAlign = numChannels * bytesPerSample;
  let result = new Float32Array(buffer.length * numChannels);
  for (let ch = 0; ch < numChannels; ch++) {
    const channelData = buffer.getChannelData(ch);
    for (let i = 0; i < buffer.length; i++) result[i * numChannels + ch] = channelData[i];
  }
  const dataLength = result.length * bytesPerSample;
  const arrayBuffer = new ArrayBuffer(44 + dataLength);
  const view = new DataView(arrayBuffer);
  const writeString = (offset, string) => { for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i)); };
  writeString(0, 'RIFF');
  view.setUint32(4, 36 + dataLength, true);
  writeString(8, 'WAVE');
  writeString(12, 'fmt ');
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, numChannels, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, sampleRate * blockAlign, true);
  view.setUint16(32, blockAlign, true);
  view.setUint16(34, bitDepth, true);
  writeString(36, 'data');
  view.setUint32(40, dataLength, true);
  let offset = 44;
  for (let i = 0; i < result.length; i++, offset += 2) {
    let sample = Math.max(-1, Math.min(1, result[i]));
    view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
  }
  return arrayBuffer;
}

// === START APP ===
init();
</script>
</body>
</html>
